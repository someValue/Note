```
// 动态规划求 最长子串（连续）
    // lcs[i][j] 的 值 表示 序列1 以 第i位 结尾  和 序列2 以第j位结尾 的 最大子串长度，
    // arr1[i+1] 和 arr2[j+1] 如果相等， 那么 lcs[i+1][j+1] = lcs[i][j] + 1, 否则 lcs[i+1][j+1] = 0
    // lcs[0][j] = (arr1[0] == arr2[j]) ? 1 : 0
    // lcs[i][0] = (arr2[0] == arr1[i]) ? 1 : 0
    //
    /*
     
        lcs[0][0] lcs[0][1] ... lcs[0][j]
     
        lcs[1][0] lcs[1][1] ... lcs[1][j]
     
        .
        lcs[5][3]  --> lcs[4][2] +1
        lcs[5][4]  --> lcs[4][3] +1    ---> 都是由 lcs[4][.] 计算
        ...
     
        lcs[5][j]
     
        .
     
        lcs[i][0] lcs[i][1] ... lcs[i][j]  --->  使用二维数组
    */
 ```